#version 310 es
//set to gles 3.1

precision highp float;
precision highp int;
// If needed, adjust sampler precision:
precision mediump sampler2D;

// Uniforms
uniform sampler2D uTexture0;
uniform sampler2D uTexture1;

uniform vec2  uTexScale0;
uniform vec2  uTexScale1;
uniform vec4  uPrimColour;
uniform vec4  uEnvColour;
uniform float uPrimLODFrac;

uniform bvec2 uTileClampEnable0;
uniform ivec2 uTileTL0;        // 10.2 fixed point
uniform ivec2 uTileBR0;        // 10.2 fixed point
uniform vec2  uTileShift0;     // floating point
uniform ivec2 uTileMask0;      // 10.5 fixed point
uniform ivec2 uTileMirror0;    // 10.5 fixed point

uniform bvec2 uTileClampEnable1;
uniform ivec2 uTileTL1;
uniform ivec2 uTileBR1;
uniform vec2  uTileShift1;
uniform ivec2 uTileMask1;
uniform ivec2 uTileMirror1;

uniform int uFoo;

// Varyings (from vertex shader)
in  vec2 v_st;
in  vec4 v_col;

// Fragment output
out vec4 fragcol;

// ----------------------------------------------------
// Utility Functions
// ----------------------------------------------------

// In ES 3.1, integer mix with bvec isn't guaranteed. So define a manual imix:
ivec2 imix(ivec2 a, ivec2 b, bvec2 c)
{
    // If c.x is true, use b.x; else a.x
    // If c.y is true, use b.y; else a.y
    return ivec2(
        c.x ? b.x : a.x,
        c.y ? b.y : a.y
    );
}

// coord:  10.5
// return: 10.5
ivec2 shift(ivec2 coord, vec2 shift_scale)
{
    // Multiply each component of coord by shift_scale
    vec2 scaled = vec2(coord) * shift_scale;
    return ivec2(scaled);
}

// Clamp a UV coord when point sampling.
// coord:  10.5
// return: 10.0, frac (0.5)
ivec2 clampPoint(ivec2 coord,
                 ivec2 tile_tl, ivec2 tile_br, bvec2 clamp_enable)
{
    ivec2 coord_clamped = clamp(coord, tile_tl << 3, tile_br << 3);
    ivec2 coord_out   
}
